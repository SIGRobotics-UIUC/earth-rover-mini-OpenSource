# 05-STM32-Control
## 简介

* RV1106&STM32通信原理
RV1106与STM32的通信协议包构成为<hd><data><ccr>，以下是详细介绍：
* 协议头
```c
typedef struct ucp_hd {
    uint16_t    len; 
    uint8_t     id;
    uint8_t     index;
} ucp_hd_t __attribute__((packed));
```
RV1106&STM32的协议包头构成如上结构体的成员部分，<0xfd 0xff>、len-协议包字节长度、id-协议包id号、index-包序号，共6个字节长度。

* 协议尾
RV1106&STM32的协议包尾构成为CRC16校验位，共2个字节长度(CRC（循环冗余校验，Cyclic Redundancy Check）是一种常见的用于检测数据传输或存储错误的校验方式。它通过多项式运算，将数据映射为一个固定长度的校验码)，最终得到2个字节长度校验码<crc1 crc2>，以下代码块为两个校验查表数组以及校验算法部分。
```c
static uint8_t crc_hi_table [ ] = { 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 ,
        0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 ,
        0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 ,
        0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 ,
        0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 ,
        0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 ,
        0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 ,
        0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 ,
        0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 ,
        0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
        0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 ,
        0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 ,
        0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 ,
        0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 ,
        0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 ,
        0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 ,
        0xC0 , 0x80 , 0x41 , 0x00 , 0xC1 , 0x81 , 0x40 , 0x01 , 0xC0 , 0x80 , 0x41 , 0x01 , 0xC0 , 0x80 , 0x41 ,
        0x00 , 0xC1 , 0x81 , 0x40 };

static uint8_t crc_lo_table [ ] = { 0x00 , 0xC0 , 0xC1 , 0x01 , 0xC3 , 0x03 , 0x02 , 0xC2 , 0xC6 , 0x06 , 0x07 , 0xC7 ,
        0x05 , 0xC5 , 0xC4 , 0x04 , 0xCC , 0x0C , 0x0D , 0xCD , 0x0F , 0xCF , 0xCE , 0x0E , 0x0A , 0xCA , 0xCB ,
        0x0B , 0xC9 , 0x09 , 0x08 , 0xC8 , 0xD8 , 0x18 , 0x19 , 0xD9 , 0x1B , 0xDB , 0xDA , 0x1A , 0x1E , 0xDE ,
        0xDF , 0x1F , 0xDD , 0x1D , 0x1C , 0xDC , 0x14 , 0xD4 , 0xD5 , 0x15 , 0xD7 , 0x17 , 0x16 , 0xD6 , 0xD2 ,
        0x12 , 0x13 , 0xD3 , 0x11 , 0xD1 , 0xD0 , 0x10 , 0xF0 , 0x30 , 0x31 , 0xF1 , 0x33 , 0xF3 , 0xF2 , 0x32 ,
        0x36 , 0xF6 , 0xF7 , 0x37 , 0xF5 , 0x35 , 0x34 , 0xF4 , 0x3C , 0xFC , 0xFD , 0x3D , 0xFF , 0x3F , 0x3E ,
        0xFE , 0xFA , 0x3A , 0x3B , 0xFB , 0x39 , 0xF9 , 0xF8 , 0x38 , 0x28 , 0xE8 , 0xE9 , 0x29 , 0xEB , 0x2B ,
        0x2A , 0xEA , 0xEE , 0x2E , 0x2F , 0xEF , 0x2D , 0xED , 0xEC , 0x2C , 0xE4 , 0x24 , 0x25 , 0xE5 , 0x27 ,
        0xE7 , 0xE6 , 0x26 , 0x22 , 0xE2 , 0xE3 , 0x23 , 0xE1 , 0x21 , 0x20 , 0xE0 , 0xA0 , 0x60 , 0x61 , 0xA1 ,
        0x63 , 0xA3 , 0xA2 , 0x62 , 0x66 , 0xA6 , 0xA7 , 0x67 , 0xA5 , 0x65 , 0x64 , 0xA4 , 0x6C , 0xAC , 0xAD ,
        0x6D , 0xAF , 0x6F , 0x6E , 0xAE , 0xAA , 0x6A , 0x6B , 0xAB , 0x69 , 0xA9 , 0xA8 , 0x68 , 0x78 , 0xB8 ,
        0xB9 , 0x79 , 0xBB , 0x7B , 0x7A , 0xBA , 0xBE , 0x7E , 0x7F , 0xBF , 0x7D , 0xBD , 0xBC , 0x7C , 0xB4 ,
        0x74 , 0x75 , 0xB5 , 0x77 , 0xB7 , 0xB6 , 0x76 , 0x72 , 0xB2 , 0xB3 , 0x73 , 0xB1 , 0x71 , 0x70 , 0xB0 ,
        0x50 , 0x90 , 0x91 , 0x51 , 0x93 , 0x53 , 0x52 , 0x92 , 0x96 , 0x56 , 0x57 , 0x97 , 0x55 , 0x95 , 0x94 ,
        0x54 , 0x9C , 0x5C , 0x5D , 0x9D , 0x5F , 0x9F , 0x9E , 0x5E , 0x5A , 0x9A , 0x9B , 0x5B , 0x99 , 0x59 ,
        0x58 , 0x98 , 0x88 , 0x48 , 0x49 , 0x89 , 0x4B , 0x8B , 0x8A , 0x4A , 0x4E , 0x8E , 0x8F , 0x4F , 0x8D ,
        0x4D , 0x4C , 0x8C , 0x44 , 0x84 , 0x85 , 0x45 , 0x87 , 0x47 , 0x46 , 0x86 , 0x82 , 0x42 , 0x43 , 0x83 ,
        0x41 , 0x81 , 0x80 , 0x40 };

static uint16_t crc16 ( char* msg , size_t len )
{
    uint8_t crc_hi = 0xFF;
    uint8_t crc_lo = 0xFF;
    uint8_t index;

    while ( len-- )
    {
        index = crc_lo ^ *msg++;
        crc_lo = crc_hi ^ crc_hi_table [ index ];
        crc_hi = crc_lo_table [ index ];
    }
    return (crc_hi << 8 | crc_lo);
}
```

* RV1106&STM32心跳包-01解析
RV1106可以通过ping包获取STM32的运行状态，以下是心跳包的组成结构
RV1106：
```c
typedef struct ucp_alive_ping {
    ucp_hd_t    hd;
} ucp_alive_ping_t __attribute__((packed));
```
RV1106的ping包组成十分简单，数据段部分是没有的，仅由一个包头包尾构成
ping包组成结构：<0xfd 0xff><hd><crc>

STM32：
```c
typedef struct ucp_alive_pong {
    ucp_hd_t    hd;
    uint8_t     err;
} ucp_alive_pong_t __attribute__((packed));
```
STM32的pong包组成相比RV1106的ping包的数据段多了一个错误码，以此反映STM32的运行状态，当错误码err = 0时，代表通信正常，err = 1则通信异常
pong包组成结构：<0xfd 0xff><hd><err><crc>

## 5.1 电机&车灯
* RV1106&STM32-控制协议包-02解析
RV1106：
```c
typedef struct ucp_ctl_cmd {
    ucp_hd_t    hd;
    int16_t     speed;
    int16_t     angular;
    int16_t     front_led;
    int16_t     back_led;
    uint16_t    version;
    uint16_t    reserve1;
    uint32_t    reserve2;
} ucp_ctl_cmd_t __attribute__((packed));
```
hd -> 包头（len-协议包字节长度、id-协议包id号、index-包序号）
speed -> 前进速度（speed > 0向前运动，speed < 0 向后运动，speed取值范围（-100 ~ 100））
angular-> 左右轮速差（angluar > 0向左运动，angluar < 0 向右运动，angluar取值范围（-100 ~ 100））
front_led-> 灯光控制（front_led = 100为开灯状态，front_led = 0为关灯状态）
back_led -> 保留位，暂不使用
version  -> 保留位，暂不使用
reserve1-> 保留位，暂不使用
reserve2 -> 保留位，暂不使用

* 电机控制
协议包组成：<0xfd 0xff><hd><speed><angular><......><crc>

* 车灯控制
协议包组成：<0xfd 0xff><hd><......><front_led><......><crc>


## 5.2 系统状态灯
* RV1106&STM32-状态灯控制协议包-0A解析
RV1106：
```c
typedef struct ucp_led_status {
    ucp_hd_t    hd;
    ucp_state_e status;
}
```
hd-> 包头（len-协议包字节长度、id-协议包id号、index-包序号）
status-> RV1106联网状态（详细见以下枚举）

```c
typedef enum ucp_state_e {
        UCP_STATE_UNKNOWN = 0,       //初始状态
        UCP_STATE_SIMABSENT = 1,     //SIM检测中 
        UCP_NETWORK_DISCONNECTED,    //联网失败
        UCP_NETWORK_CONNECTED,       //联网成功
} ucp_state_e;
```
* 状态灯控制
状态灯控制协议包组成结构：<0xfd 0xff><hd><status><crc>
## 5.4 系统电源
* RV1106&STM32-回传协议包-05解析
该协议包STM32自动上报RV1106,每20ms发送一包
STM32：
```c
typedef struct ucp_rep { //report
    ucp_hd_t    hd;
    uint16_t    battery;
    int16_t     rpm[4];
    uint8_t     power;
    uint8_t     voltage;
    uint16_t    current;
    int16_t     acc[3];
    int16_t     gyros[3];
    int16_t     mag[3];
    int16_t     heading;
} ucp_rep_t __attribute__((packed));
```
hd              -> 包头（len-协议包字节长度、id-协议包id号、index-包序号）
battery         -> 电池电量百分比（battery取值范围（-100 ~ 100））
power           -> 系统功率（W）
voltage         -> 系统电压（10 * V）
current         -> 系统电流（100 * A）

* 电源数据读取示例
## 5.5 IMU
### 5.5.1 IMU校准
* RV1106&STM32-IMU校准协议包-03解析

* RV1106&STM32-IMU校准协议包-04解析

### 5.5.2 IMU数据获取
* RV1106&STM32-回传协议包-05解析

### 5.5.3 保存校准数据
* RV1106&STM32-IMU校准回传协议包-06解析

* RV1106&STM32-IMU校准回传协议包-07解析

